"""
Export functionality for quiz questions in various formats
"""
import json
import csv
import io
from datetime import datetime
from typing import List, Dict

def export_to_json(questions: List[Dict]) -> bytes:
    """Export questions to clean JSON format"""
    # Clean and structure the data
    export_data = {
        "quiz_metadata": {
            "total_questions": len(questions),
            "export_timestamp": datetime.now().isoformat(),
            "format": "JSON",
            "version": "1.0"
        },
        "questions": []
    }
    
    for i, question in enumerate(questions):
        question_data = {
            "id": i + 1,
            "question": question.get("question", ""),
            "options": {
                "A": question.get("options", ["", "", "", ""])[0] if len(question.get("options", [])) > 0 else "",
                "B": question.get("options", ["", "", "", ""])[1] if len(question.get("options", [])) > 1 else "",
                "C": question.get("options", ["", "", "", ""])[2] if len(question.get("options", [])) > 2 else "",
                "D": question.get("options", ["", "", "", ""])[3] if len(question.get("options", [])) > 3 else ""
            },
            "correct_answer": question.get("correct_answer", ""),
            "explanation": question.get("explanation", ""),
            "difficulty": question.get("difficulty", "medium"),
            "bloom_level": question.get("bloom_level", "understand"),
            "subject_area": question.get("subject_area", "general"),
            "key_concept": question.get("key_concept", "")
        }
        export_data["questions"].append(question_data)
    
    # Convert to JSON bytes
    json_string = json.dumps(export_data, indent=2, ensure_ascii=False)
    return json_string.encode('utf-8')

def export_to_csv(questions: List[Dict]) -> bytes:
    """Export questions to CSV format for spreadsheet applications"""
    output = io.StringIO()
    writer = csv.writer(output)
    
    # Write header
    writer.writerow([
        "Question", "Option A", "Option B", "Option C", "Option D", 
        "Correct Answer", "Explanation", "Difficulty", "Bloom Level", "Subject Area"
    ])
    
    # Write question data
    for question in questions:
        options = question.get("options", ["", "", "", ""])
        
        # Ensure we have 4 options
        while len(options) < 4:
            options.append("")
        
        row = [
            question.get("question", ""),
            options[0],
            options[1], 
            options[2],
            options[3],
            question.get("correct_answer", ""),
            question.get("explanation", ""),
            question.get("difficulty", "medium"),
            question.get("bloom_level", "understand"),
            question.get("subject_area", "general")
        ]
        writer.writerow(row)
    
    # Convert to bytes
    csv_content = output.getvalue()
    output.close()
    return csv_content.encode('utf-8')

def export_to_moodle_xml(questions: List[Dict]) -> bytes:
    """Export questions to Moodle XML format with proper CDATA wrapping"""
    xml_content = '<?xml version="1.0" encoding="UTF-8"?>\n'
    xml_content += '<quiz>\n'
    xml_content += '<!-- Generated by Smart Quiz Generator -->\n'
    xml_content += f'<!-- Export Date: {datetime.now().strftime("%Y-%m-%d %H:%M:%S")} -->\n\n'
    
    for i, question in enumerate(questions, 1):
        xml_content += f'  <question type="multichoice">\n'
        xml_content += f'    <name>\n'
        xml_content += f'      <text>Question {i}</text>\n'
        xml_content += f'    </name>\n'
        xml_content += f'    <questiontext format="html">\n'
        xml_content += f'      <text><![CDATA[{question.get("question", "")}]]></text>\n'
        xml_content += f'    </questiontext>\n'
        xml_content += f'    <generalfeedback format="html">\n'
        xml_content += f'      <text><![CDATA[{question.get("explanation", "")}]]></text>\n'
        xml_content += f'    </generalfeedback>\n'
        xml_content += f'    <defaultgrade>1.0000000</defaultgrade>\n'
        xml_content += f'    <penalty>0.3333333</penalty>\n'
        xml_content += f'    <hidden>0</hidden>\n'
        xml_content += f'    <single>true</single>\n'
        xml_content += f'    <shuffleanswers>true</shuffleanswers>\n'
        xml_content += f'    <answernumbering>abc</answernumbering>\n'
        
        # Add answers
        options = question.get("options", [])
        correct_answer = question.get("correct_answer", "")
        
        for j, option in enumerate(options):
            if option:  # Only add non-empty options
                fraction = "100.0000000" if option == correct_answer else "0.0000000"
                xml_content += f'    <answer fraction="{fraction}" format="html">\n'
                xml_content += f'      <text><![CDATA[{option}]]></text>\n'
                xml_content += f'      <feedback format="html">\n'
                xml_content += f'        <text></text>\n'
                xml_content += f'      </feedback>\n'
                xml_content += f'    </answer>\n'
        
        # Add metadata as tags
        xml_content += f'    <tags>\n'
        xml_content += f'      <tag><text>difficulty:{question.get("difficulty", "medium")}</text></tag>\n'
        xml_content += f'      <tag><text>bloom:{question.get("bloom_level", "understand")}</text></tag>\n'
        xml_content += f'      <tag><text>subject:{question.get("subject_area", "general")}</text></tag>\n'
        xml_content += f'    </tags>\n'
        
        xml_content += f'  </question>\n\n'
    
    xml_content += '</quiz>'
    
    return xml_content.encode('utf-8')

def export_to_gift(questions: List[Dict]) -> bytes:
    """Export questions to Moodle GIFT format"""
    gift_content = f"// Smart Quiz Generator Export\n"
    gift_content += f"// Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n"
    gift_content += f"// Total Questions: {len(questions)}\n\n"
    
    for i, question in enumerate(questions, 1):
        # Question title (optional in GIFT)
        gift_content += f"// Question {i}\n"
        gift_content += f"// Difficulty: {question.get('difficulty', 'medium')}\n"
        gift_content += f"// Bloom Level: {question.get('bloom_level', 'understand')}\n"
        
        # Question text
        question_text = question.get("question", "").replace("{", "\\{").replace("}", "\\}")
        gift_content += f"{question_text} {{\n"
        
        # Options
        options = question.get("options", [])
        correct_answer = question.get("correct_answer", "")
        
        for option in options:
            if option:  # Only add non-empty options
                option_escaped = option.replace("{", "\\{").replace("}", "\\}")
                if option == correct_answer:
                    gift_content += f"    ={option_escaped}\n"
                else:
                    gift_content += f"    ~{option_escaped}\n"
        
        gift_content += "}\n"
        
        # Add explanation as feedback
        explanation = question.get("explanation", "")
        if explanation:
            explanation_escaped = explanation.replace("{", "\\{").replace("}", "\\}")
            gift_content += f"// Explanation: {explanation_escaped}\n"
        
        gift_content += "\n"
    
    return gift_content.encode('utf-8')

def get_file_size_string(data_bytes: bytes) -> str:
    """Convert bytes to human-readable file size"""
    size = len(data_bytes)
    
    if size < 1024:
        return f"{size} bytes"
    elif size < 1024 * 1024:
        return f"{size / 1024:.1f} KB"
    else:
        return f"{size / (1024 * 1024):.1f} MB"

def get_timestamp_filename(base_name: str, extension: str) -> str:
    """Generate filename with timestamp"""
    timestamp = datetime.now().strftime("%Y_%m_%d_%H%M%S")
    return f"{base_name}_{timestamp}.{extension}"
